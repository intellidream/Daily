@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime

<div class="film-strip-wrapper my-4" style="position: relative; width: 100%; height: 100px; user-select: none; -webkit-user-select: none; -webkit-mask-image: linear-gradient(to right, transparent 0%, black 15%, black 85%, transparent 100%); mask-image: linear-gradient(to right, transparent 0%, black 15%, black 85%, transparent 100%);">
    
    <!-- Scroll Track -->
    <div @ref="_scrollContainer" 
         class="d-flex align-center overflow-x-auto hide-scrollbar h-100"
         style="cursor: grab; scroll-behavior: smooth; white-space: nowrap; padding-left: 40%; padding-right: 40%; touch-action: pan-x;"
         id="@_componentId"
         @onmousedown="OnMouseDown"
         @onmousemove="OnMouseMove"
         @onmouseup="OnMouseUp"
         @onmouseleave="OnMouseUp">
        
        @foreach (var date in _dates)
        {
            var isSelected = date.Date == SelectedDate.Date;
            var isToday = date.Date == DateTime.Today;
            
            <div @key="date"
                 class="d-flex flex-column justify-center align-center flex-shrink-0 date-item mx-1 rounded-lg @(isSelected ? "selected shadow-lg" : "")" 
                 style="width: 20%; min-width: 70px; height: 80px; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); opacity: @(isSelected ? 1 : 0.4); transform: scale(@(isSelected ? 1.15 : 0.9)); position: relative;"
                 @onclick="@(() => SelectDate(date))"
                 @onclick:stopPropagation="true">
                 
                 @if(isToday)
                 {
                     <div style="position: absolute; top: 6px; right: 6px; width: 8px; height: 8px; background-color: var(--mud-palette-info); border-radius: 50%; box-shadow: 0 0 5px var(--mud-palette-info);"></div>
                 }
                 
                 <!-- Year (Vertical Left, Subtle) -->
                 <MudText Typo="Typo.caption" 
                          Style="position: absolute; left: 4px; top: 50%; transform: translateY(-50%) rotate(-180deg); writing-mode: vertical-rl; font-size: 0.6rem; opacity: 0.25; letter-spacing: 1px; pointer-events: none;" 
                          Color="@(isSelected ? Color.Primary : Color.Inherit)">
                     @date.ToString("yyyy")
                 </MudText>

                <MudText Typo="Typo.caption" Class="font-weight-bold" Style="letter-spacing: 1px; opacity: 0.8;" Color="@(isSelected ? Color.Primary : Color.Inherit)">
                    @date.ToString("MMM").ToUpper()
                </MudText>
                <MudText Typo="Typo.h5" Class="font-weight-bold my-0" Color="@(isSelected ? Color.Primary : Color.Inherit)">
                    @date.Day
                </MudText>
                <MudText Typo="Typo.caption" Color="@(isSelected ? Color.Primary : Color.Inherit)" Style="opacity: 0.8;">
                     @date.ToString("ddd")
                </MudText>
            </div>
        }
    </div>
</div>

<style>
    .hide-scrollbar::-webkit-scrollbar {
        display: none;
    }
    .hide-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
    .date-item.selected {
        background-color: var(--mud-palette-surface);
        border: 1px solid var(--mud-palette-lines-default);
        /* Theme aware color */
        color: var(--mud-palette-text-primary); 
    }
    
    /* Dark Mode Override if needed, but Mud variables usually handle it. 
       Let's ensure it pops. */
    .date-item:hover {
        background-color: var(--mud-palette-action-hover);
    }
    .date-item:active {
        cursor: grabbing;
    }
    /* Prevent default drag ghost image */
    .date-item, .film-strip-wrapper {
        -webkit-user-drag: none;
    }
</style>

@code {
    [Parameter] public DateTime StartDate { get; set; }
    [Parameter] public DateTime EndDate { get; set; } = DateTime.Today;
    [Parameter] public DateTime SelectedDate { get; set; }
    [Parameter] public EventCallback<DateTime> SelectedDateChanged { get; set; }

    private ElementReference _scrollContainer;
    private string _componentId = "filmstrip-" + Guid.NewGuid().ToString("N");
    private List<DateTime> _dates = new();
    
    // Drag State
    private bool _isDown = false;
    private double _startX;
    private double _scrollLeft;
    private bool _isDragging = false;

    protected override void OnParametersSet()
    {
        _dates.Clear();
        // Ensure robust date range
        var start = StartDate;
        var end = EndDate;
        
        // Safety: If start is invalid or future, default to 30 days back
        if (start == DateTime.MinValue || start > end) start = end.AddDays(-30);
        
        // If range is suspiciously small (e.g. < 5 days), maybe User just started? 
        // We stick to the request: "from started date... up to current date".
        // But if started date IS today, we should probably show at least a few empty slots or history?
        // Current logic in Parent forces 30 days if QuitDate is Today. So we strictly follow parameters here.

        var current = start.Date;
        while (current <= end.Date)
        {
            _dates.Add(current);
            current = current.AddDays(1);
        }
    }


    
    private async Task ScrollToSelected()
    {
       var index = _dates.FindIndex(d => d.Date == SelectedDate.Date);
       if(index >= 0)
       {
           // Center the selected item
           await JSRuntime.InvokeVoidAsync("eval", $@"
                var el = document.getElementById('{_componentId}');
                if(el) {{
                    var children = el.children;
                    if(children && children[{index}]) {{
                        var child = children[{index}];
                        var center = child.offsetLeft + child.offsetWidth / 2;
                        var scroll = center - el.offsetWidth / 2;
                        el.scrollTo({{ left: scroll, behavior: 'smooth' }});
                    }}
                }}
           ");
       }
    }

    // --- MOUSE DRAG LOGIC (C# Hybrid) ---
    // We use JS for the heavy lifting normally, but C# event handlers are fine for state flags
    // actually, for smooth high-frequency drag, JS is better. 
    // The previous implementation had 'window shake', possibly due to event bubbling. 
    // We will use a stricter JS implementation here that stops propagation.
    
    private void OnMouseDown(MouseEventArgs e)
    {
        // Handled in JS now to prevent bubbling issues more reliably
    }
    
    // Re-inject the JS with stopPropagation and careful handling
    protected override async Task OnInitializedAsync()
    {
         await base.OnInitializedAsync();
         // We do this in OnAfterRender normally, but defining the script string here:
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
             await JSRuntime.InvokeVoidAsync("eval", @"
                window.initFilmStripDragRobust = function(id) {
                    const el = document.getElementById(id);
                    if(!el) return;
                    
                    let isDown = false;
                    let startX;
                    let scrollLeft;
                    let isDragging = false;
                    
                    el.addEventListener('mousedown', (e) => {
                        isDown = true;
                        isDragging = false;
                        el.style.cursor = 'grabbing';
                        el.style.scrollBehavior = 'auto'; // Disable smooth scroll while dragging
                        startX = e.pageX - el.offsetLeft;
                        scrollLeft = el.scrollLeft;
                        
                        // CRITICAL: Stop propagation to prevent window drag
                        e.stopPropagation();
                        e.preventDefault(); 
                    });
                    
                    el.addEventListener('mouseleave', () => {
                        isDown = false;
                        el.style.cursor = 'grab';
                        el.style.scrollBehavior = 'smooth';
                    });
                    
                    el.addEventListener('mouseup', (e) => {
                        isDown = false;
                        el.style.cursor = 'grab';
                        el.style.scrollBehavior = 'smooth';
                        
                        if (isDragging) {
                             el.setAttribute('data-dragged', 'true');
                             setTimeout(() => el.removeAttribute('data-dragged'), 50);
                        }
                        e.stopPropagation();
                    });
                    
                    el.addEventListener('mousemove', (e) => {
                        if(!isDown) return;
                        e.preventDefault();
                        e.stopPropagation(); // Stop window shake?
                        
                        const x = e.pageX - el.offsetLeft;
                        const walk = (x - startX) * 2; 
                        if(Math.abs(walk) > 5) isDragging = true;
                        el.scrollLeft = scrollLeft - walk;
                    });
                    
                    // Add touch support just in case
                     el.addEventListener('touchstart', (e) => {
                         // touch usually handled by overflow-auto, but we might want to stop propagation
                         e.stopPropagation();
                     }, { passive: false });
                     
                     el.addEventListener('touchmove', (e) => {
                         e.stopPropagation();
                     }, { passive: false });
                }
            ");
            
            await JSRuntime.InvokeVoidAsync("initFilmStripDragRobust", _componentId);
            await ScrollToSelected();
        }
    }

    private void OnMouseMove(MouseEventArgs e) {}
    private void OnMouseUp(MouseEventArgs e) {}

    private async Task SelectDate(DateTime date)
    {
        // Check dragging flag from JS
        var isDragged = await JSRuntime.InvokeAsync<string>("eval", $"document.getElementById('{_componentId}').getAttribute('data-dragged')");
        if (isDragged == "true") return;

        SelectedDate = date;
        await SelectedDateChanged.InvokeAsync(date);
        await ScrollToSelected();
    }
}
